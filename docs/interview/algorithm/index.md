# 算法

## el-input 输入数字转化为千分位

```js
// 金额添加千分位
const comdify = function (n) {
    if (!n) return n
   const str = n.split('.');
    const reg = /\d{1,3}(?=(\d{3})+$)/g;
    const n1 = str[0].replace(reg, '$&,');
    return str.length > 1 && str[1] ? `${n1}.${str[1].slice(0,2)}` : `${n1}.00`
}

// 去除千分位中的‘,’
const delcomdify = function (n) {
    if (!n) return n
    n = n.toString()
    n = n.replace(/,/gi, '')
    return n
}
```

## 关于正则表达式中 `?=` `?!`  `?<=` `?<!` `?:` 的理解与应用

### 官方解释

+ `(?=pattern): 正向先行断言`，表示匹配位置后面必须紧跟着满足pattern的字符串，但不包括这个字符串在匹配结果中。
+ `(?!pattern): 负向先行断言`，表示匹配位置后面不能紧跟着满足pattern的字符串，也不包括这个字符串在匹配结果中。
+ `(?<=pattern): 正向后行断言`，表示匹配位置前面必须是满足pattern的字符串，但不包括这个字符串在匹配结果中。
+ `(?<=!pattern): 负向后行断言`，表示匹配位置前面不能是满足pattern的字符串，也不包括这个字符串在匹配结果中。
+ `(?:pattern): 非捕获型分组`，表示将 pattern 包含在一个分组中，但不把这个分组的匹配结果保存到分组编号中。这个分组通常用于表示可选的或重复的子表达式，或者是限制量词的作用范围，而不需要把它们的匹配结果单独提取出来。

### 通俗解释
+ `RegExp1(?=RegExp2)`: 匹配后面是`RegExp2`的`RegExp1`
+ `RegExp1(?!RegExp2)`: 匹配后面不是`RegExp2`的`RegExp1`
+ `(?<=RegExp2)RegExp1`: 匹配前面是`RegExp2`的`RegExp1`
+ `(?<!RegExp2)RegExp1`: 匹配前面不是`RegExp2`的`RegExp1`
+ `(?:RegExp)`  这个等下单独解释，与上面的不太一样

其实 `?=` `?!`  `?<=` `?<!` 的意思可以理解为`if判断`,只有先通过它们(`RegExp2`)的判断之后，才可以获取到正则(`RegExp1`)的匹配结果。 `RegExp2匹配到的内容是不会返回的，也不会消耗匹配到的字符，只会返回RegExp1的匹配结果`，这就是`零宽度断言`，零宽度断言在正则表达式中非常有用，因为它们可以在不改变匹配结果的情况下，对匹配位置前后的内容进行限制或判断。

###  `?:`的解释
 > (`?:`) 并不是零宽度断言，而是`非捕获组`，它跟普通的括号 () 的区别在于，它不会保存匹配到的内容，但是它仍然会消耗字符并返回匹配内容，只是不会保存匹配结果。

> - ()表示捕获分组，它会把匹配到的内容保存到内存中，开发者可以使用$n(n是一个数字)来代表第n个()中匹配到的内容
> - (?:)表示非捕获组，它匹配的内容不会被保存，所以无法使用$n获取，但也因为没有被保存所以节省了一部分内存空间


### 举例
#### ?=
```js
'我喜欢苹果'.replace(/我喜欢(?=苹果)/, '我讨厌')  // 我讨厌苹果
'我喜欢橘子'.replace(/我喜欢(?=苹果)/, '我讨厌')  // 我喜欢橘子
```

#### ?!
```js
'我喜欢苹果'.replace(/我喜欢(?!苹果)/, '我讨厌')  // 我喜欢苹果
'我喜欢橘子'.replace(/我喜欢(?!苹果)/, '我讨厌')  // 我讨厌橘子
```

#### ?<=
```js
'我喜欢苹果'.replace(/(?<=我喜欢)苹果/, '西红柿')  //我喜欢西红柿
'我喜欢橘子'.replace(/(?<=我喜欢)苹果/, '西红柿')  //我喜欢橘子
```
#### ?<!
```js
'我讨厌苹果'.replace(/(?<!我喜欢)苹果/, '西红柿')  //我讨厌西红柿
'我喜欢苹果'.replace(/(?<!我喜欢)苹果/, '西红柿')  //我喜欢苹果
```

#### ?:
```js
'hello world'.replace(/(?:hello) (world)/, '$1') // 匹配的内容为hello world,$1取的是world，故结果为world
```


### 特殊情况

> `/(?=.*[A-Z])[A-Za-z]{5,10}/`

当`(?=)`前面没内容，或者说`(?=)`被放在开头使用，`(?=)`的作用就相当于`检索全部内容是否符合它的要求`，如果不符合，就没必要继续向后匹配了，这很像`if(true)`时，才能执行后面的内容。<br/>

上面的正则意为: `先检查内容中是否至少包含一个大写字母，如果有，则继续检查并匹配5~10个大小写字母，并返回`


### 应用实例
#### 姓名脱敏（添加*号）
```js
'李小龙'.replace(/(?<=[\u4e00-\u9fa5])[\u4e00-\u9fa5]/g, '*') // 李**
```
#### 手机号、银行账号脱敏
```js
'15891399322'.replace(/(?<=\d{3})\d(?=\d{4})/g, '*')  // 158****9322
'15891399322'.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2") // 158****9322
```

#### 强密码规则校验
```js
// 密码不能为空， 8-30位， 至少包含一个大写字母、小写字母、数字、特殊字符
/^(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[\W_])(?!.*[\u4e00-\u9fa5])(?!\s)[a-zA-Z0-9\W_]{8,30}$/

// \d 表示数字
// \D 表示非数字

// \w 表示一个字 [0－9a-zA-Z_]  大小写、数字、下划线
// \W 表示除 [0－9a-zA-Z_] 之外的字符

// \s 表示一个空白字符(空格、tab、换页符 等)
// \S 表示一个非空白字符

```
