# Vue2 

### computed 和 methods 的区别

- 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。
- 然而，不同的是计算属性是基于它们的响应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。
- 这就意味着只要依赖项还没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。


### key的作用
比如一个列表，需要往中间插入一个元素，如果`以下标作为对应关系`时，`不使用key`或者`使用列表的index作为key`,会导致插入元素到后面的全部元素，对应的位置关系发生变更，全都需要执行更新操作。

我们希望的是只渲染添加的那一个元素， 其他元素不做任何变更。

`使用唯一key值`: 只会渲染要更新的元素，其他元素内容没发生改变，对应的位置关系也没有发生改变。

总结特点:
- key 的作用主要是为了更高效的更新虚拟 DOM，因为它可以非常精确的找到相同节点，因此 patch 过程会非常高效
- Vue 在 patch 过程中会判断两个节点是不是相同节点时，key 是一个必要条件。比如渲染列表时，如果不写 key，Vue 在比较的时候，就可能会导致频繁更新元素，使整个 patch 过程比较低效，影响性能
- 应该避免使用数组下标作为 key

### diff算法核心原理
#### patch
它可以接收四个参数:
- oldValue : 老的虚拟DOM节点
- vnode ：新的虚拟DOM节点
- hydrating: 是不是要和真实DOM混合
- removeOnly

### 父子组件生命周期先后顺序
>挂载阶段

执行顺序为： 父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted

>更新阶段

- 执行顺序为： 父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated

>销毁阶段

- 执行顺序为： 父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed；

规律就是：父组件先开始执行，然后等到子组件执行完，父组件收尾。

### 数据双向绑定原理
Vue的双向绑定是基于`数据劫持`和`发布-订阅者模式`, 通过`Object.defineProperty()方法`来实现的。

+ 数据劫持
+ 依赖收集
+ 数据变化通知
+ 视图更新

1. Vue初始化时，会对data中的每个属性进行遍历，利用`Object.defineProperty`方法为属性添加getter和setter，在getter中收集依赖，在setter中通知依赖更新, 这样，当属性被访问或修改时，就会触发相应的getter或setter函数，从而实现对数据变化的监听。

2. 在Vue中存在一个依赖收集的过程，当`某个数据属性在模板中被使用时`，Vue就会为该属性添加一个订阅者(Watcher),这个订阅者会记录该数据属性与那些视图元素相关联。在数据属性的`getter函数中，会进行依赖收集`的操作，将该属性的所有订阅者收集到一个`依赖列表(deps)`中。

3. 当数据发生变化时，即属性的`setter`函数被调用时，Vue会`通知`所有依赖于该数据的订阅者进行`更新`。这个过程是通过发布-订阅者模式来实现的。`每个订阅者都维护着一个更新函数`，当接收到数据变化的通知时，就会执行这个更新函数，从而更新与之相关联的视图元素。


4. 最后，Vue会根据订阅者提供的更新函数，对DOM进行操作，实现视图的更新。这个过程是`异步`的，Vue会通过一个`调度器`来管理和优化这些更新操作，以提高性能和响应速度。

这四个步骤相互协作，实现了Vue中数据与视图之间的双向绑定和自动更新功能。<br/>

此外，Vue还提供了v-model指令来简化表单元素与数据之间的双向绑定操作。通过v-model指令，我们可以轻松地将表单元素的值与Vue实例中的数据属性进行绑定，并实现双向同步更新。



