import{_ as e,c as o,o as l,d as s}from"./app.008430f5.js";const n="/lucky-blog/vite/image.png",t="/lucky-blog/vite/image-1.png",a="/lucky-blog/vite/image-2.png",g=JSON.parse('{"title":"原理","description":"","frontmatter":{},"headers":[{"level":2,"title":"bin文件夹(vite源码分析之dev)","slug":"bin文件夹-vite源码分析之dev","link":"#bin文件夹-vite源码分析之dev","children":[]},{"level":2,"title":"请求时编译 && 依赖预构建","slug":"请求时编译-依赖预构建","link":"#请求时编译-依赖预构建","children":[{"level":3,"title":"vite包","slug":"vite包","link":"#vite包","children":[]},{"level":3,"title":"vite在开发环境下，起了一个做编译的服务器，根据请求的URL找到对应的模块做编译之后返回。","slug":"vite在开发环境下-起了一个做编译的服务器-根据请求的url找到对应的模块做编译之后返回。","link":"#vite在开发环境下-起了一个做编译的服务器-根据请求的url找到对应的模块做编译之后返回。","children":[]},{"level":3,"title":"浏览器支持ES Module的import请求时编译的两个问题","slug":"浏览器支持es-module的import请求时编译的两个问题","link":"#浏览器支持es-module的import请求时编译的两个问题","children":[]}]}],"relativePath":"advance/vite/principle.md","lastUpdated":null}'),c={name:"advance/vite/principle.md"},i=s('<h1 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-hidden="true">#</a></h1><h2 id="bin文件夹-vite源码分析之dev" tabindex="-1">bin文件夹(<a href="https://blog.csdn.net/qq_44859233/article/details/130904277" target="_blank" rel="noreferrer">vite源码分析之dev</a>) <a class="header-anchor" href="#bin文件夹-vite源码分析之dev" aria-hidden="true">#</a></h2><p>当执行<code>npm run dev</code>这条命令时，<code>package.json</code>中对应的脚本为<code>&quot;dev&quot;: &quot;vite&quot;</code><br></p><p>这里的dev对应的的vite，就会去<code>/node_modules/.bin</code>文件夹中去找名为<code>vite</code>的二进制文件 <br></p><p>在该文件夹下，有两个同名的可执行文件，没有后缀名的对应的时unix系统的shell脚本，.cmd后缀对应windows下的bat脚本，实质都是用node执行一个js文件。 <br></p><p>每当执行<code>npm run</code>，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。 <br></p><p>执行脚本就可以用脚本名调用，像正常执行一个 js 文件要 node 在加上执行文件的路径。</p><p>在npm install 时， npm读到该配置，就会将该文件连接到<code>/node_modules/.bin</code>目录下，npm还会将当前目录的<code>node_modules/.bin加入PATH变量</code>，执行结束后，再将PATH变量恢复原样，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了。 <br></p><p>当使用<code>npm install -g xxx</code>来安装，那么会将其中的 bin 文件加入到全局，比如 create-react-app 和 vue-cli ，在全局安装后，就可以直接使用如<code>vue-cli projectName</code>这样的命令来创建项目了</p><p><img src="'+n+'" alt="alt text"></p><p>参考:</p><ul><li><a href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json#bin" target="_blank" rel="noreferrer">npm CLI bin</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noreferrer">npm scripts 使用指南</a></li><li><a href="https://www.jianshu.com/p/53feedd72bcb" target="_blank" rel="noreferrer">执行npm run dev的时候发生了什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/616539774?utm_id=0" target="_blank" rel="noreferrer">node_modules目录中的bin文件夹</a></li></ul><p>拓展:</p><ul><li><a href="https://www.cnblogs.com/lijinxiao/articles/17333543.html" target="_blank" rel="noreferrer">npm link 用法个人总结</a></li><li><a href="https://www.cnblogs.com/zhangzl419/p/15210835.html" target="_blank" rel="noreferrer">npm link的用法</a></li></ul><p>执行顺序: <img src="'+t+`" alt="alt text"></p><h2 id="请求时编译-依赖预构建" tabindex="-1">请求时编译 &amp;&amp; 依赖预构建 <a class="header-anchor" href="#请求时编译-依赖预构建" aria-hidden="true">#</a></h2><h3 id="vite包" tabindex="-1">vite包 <a class="header-anchor" href="#vite包" aria-hidden="true">#</a></h3><p><code>/node_modules/vite/dist/node/cli.js</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> cac </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">CAC</span><span style="color:#A6ACCD;">(name)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> cli </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cac</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vite</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// cac（Command And Conquer） 是一个用于构建 CLI 应用程序的 JavaScript 库。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 有如下命令</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// cli.command(&#39;[root]&#39;, &#39;start dev serve&#39;)   运行</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// cli.command(&#39;[build root]&#39;)  打包</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// cli.command(&#39;optimize [root]&#39;, &#39;pre-bundle dependencies&#39;) 用于对Vite项目进行生产环境构建与优化</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// cli.command(&#39;preview [root]&#39;, &#39;locally preview production build&#39;)  预览生产环境构建结果</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// cli.help();  查看Vite CLI提供的所有命令与选项的帮助信息</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// cli.version(require(&#39;../../package.json&#39;).version);   查看当前项目中使用的Vite版本</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// cli.parse();   解析Vite项目中的import语句与别名,获得其最终解析结果</span></span>
<span class="line"></span></code></pre></div><p><strong>\\node_modules\\vite\\dist\\node\\chunks\\dep-bb8a8339.js:</strong></p><ul><li>resolveHttpServer： 直接使用<code>node</code>自带的<code>http</code>模块创建一个http服务</li><li>createWebSocketServer: 在<code>node</code>端<code>封装websocket</code>,返回<code>listen</code>、<code>on</code>、<code>off</code>、<code>send</code>、<code>close</code>、<code>clients</code>属性</li><li>handleHMRUpdate: 判断<code>配置文件发生改变</code>、<code>.env环境变量改变</code>、 <code>依赖发生改变</code>等情况就要重启服务server.restart(); 判断<code>仅客户端</code>、<code>html文件发生变化</code>等情况不能热更新，发送send(&#39;full-reload&#39;),让客户端重新加载页面。</li><li>updateModules: 当有监听到有模块更新，<code>moduleGraph</code>就有发生改变,去除无效的模块, 找到需要更新的模块,最后当发出send类型为update类型, 就是一个文件发生变化啦</li></ul><p><strong>\\node_modules\\vite\\dist\\client</strong> node端发送socket,在客户端就要监听socket处理文件</p><br><p>客户端处理socket的文件:</p><p>createServer --&gt; _createServer --&gt; resolveConfig --&gt; resolvePlugins --&gt; importAnalysisPlugin</p><p>importAnalysisPlugin里面通过字符串导入方式把<code>createHotContext</code>导入到了客户端</p><p>通过外部的npm包:<code>magic-string</code></p><p>在createHotContent中, 就存在<code>setupWebSocket</code>啦</p><p><img src="`+a+'" alt="alt text"></p><h3 id="vite在开发环境下-起了一个做编译的服务器-根据请求的url找到对应的模块做编译之后返回。" tabindex="-1">vite在开发环境下，起了一个做编译的服务器，根据请求的URL找到对应的模块做编译之后返回。 <a class="header-anchor" href="#vite在开发环境下-起了一个做编译的服务器-根据请求的url找到对应的模块做编译之后返回。" aria-hidden="true">#</a></h3><br> 简单的步骤: <ul><li>vite会使用<code>createServer()</code>起一个开发服务器</li><li>这个开发服务器是基于connect实现的，vite给它加了很多中间件来处理请求 <code>viteIndexHtmlMiddleware</code> <code>viteHtmlFallbackMiddleware</code> <code>viteServeStaticMiddleware</code> <code>viteServeRawFsMiddleware</code> <code>viteTransformMiddleware</code> 当请求<code>index.html</code>时，它会通过<code>ast</code>遍历，找到其中所有的<code>script</code>,然后提前对这些文件做编译，编译是通过不同的插件完成的，每个插件都会判断处理对应的资源，比如有<code>css</code>插件来编译css,<code>esbuild</code>插件来编译<code>ts/js</code>，然后返回编译后的<code>code</code>和<code>sourcemap</code>, <code>import-analysis</code>插件，在<code>esbuild</code>插件完成编译后，分析模块依赖，继续处理其他模块的transform.</li><li>只要浏览器访问<code>index.html</code>，所有依赖的js模块，都会经过编译，所以成vite为<code>no bundle</code>方案，它只是基于浏览器的<code>module import</code>,在请求时对模块做下编译。</li></ul><h3 id="浏览器支持es-module的import请求时编译的两个问题" tabindex="-1">浏览器支持ES Module的import请求时编译的两个问题 <a class="header-anchor" href="#浏览器支持es-module的import请求时编译的两个问题" aria-hidden="true">#</a></h3><ul><li>问题一： 如果node_modules下的依赖有用 commonjs 模块规范的代码呢?</li><li>问题二: 如果每个模块都是请求时编译，那向 lodash-es 这种包，它可是有几百个模块的 import 呢?</li></ul><p>就要提前做一些转换，把 commonjs 转成 es module， 还有提前对这些包做一次打包，变成一个 es module 模块； 在启动完开发服务器的时候，就马上对 node_modules 下的代码做打包，这个也叫 <code>deps optimize，依赖优化</code></p><p>首先，扫描出所有的依赖来，这一步由esbuild做的，对入口 index.html 开始做打包，输出格式为 esm，但是 write 为 false，不写入磁盘, 输出到<code>node_modules/.vite</code> 下，并生成了一个 <code>metadata.jso</code>n 来记录 <code>hash</code>。</p><p>浏览器里用 <code>max-age 强缓存</code>这些预打包的模块，但是带了 <code>hash 的query</code>。这样当重新 build 的时候，可以<code>通过修改 query 来触发更新</code>。</p><p>在开发时通过 connect 起了一个服务器，调用 vite 插件来做 transform，并且对 node_modules 下的模块做了预构建，用 esbuild 打包。</p><p>在生产环境用 rollup 来打包，因为 vite 插件兼容了 rollup 插件，所以也是用同样的插件来处理，这样能保证开发和生产环境代码一致。</p><p>此外，vite 还基于 chokidar 和 websocket 来实现了模块热更新。</p><p>vite 插件时兼容 rollup 插件的，这样在开发的时候，在生产环境打包的时候，都可以用同样的插件对代码做 transform 等处理。</p><p>处理用的插件都一样，又怎么会开发和生产不一致呢？</p>',43),d=[i];function p(r,m,u,h,v,b){return l(),o("div",null,d)}const _=e(c,[["render",p]]);export{g as __pageData,_ as default};
