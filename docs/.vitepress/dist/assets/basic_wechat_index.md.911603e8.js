import{_ as e,c as o,o as c,d}from"./app.008430f5.js";const l="/lucky-blog/wechat/smallapp.png",t="/lucky-blog/wechat/dom.png",i="/lucky-blog/wechat/life.png",r="/lucky-blog/wechat/reload.png",f=JSON.parse('{"title":"微信小程序","description":"","frontmatter":{},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"通信","slug":"通信","link":"#通信","children":[{"level":3,"title":"渲染DOM","slug":"渲染dom","link":"#渲染dom","children":[]}]},{"level":2,"title":"运行机制","slug":"运行机制","link":"#运行机制","children":[]},{"level":2,"title":"小程序与H5","slug":"小程序与h5","link":"#小程序与h5","children":[]},{"level":2,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]}],"relativePath":"basic/wechat/index.md","lastUpdated":null}'),a={name:"basic/wechat/index.md"},n=d('<h1 id="微信小程序" tabindex="-1">微信小程序 <a class="header-anchor" href="#微信小程序" aria-hidden="true">#</a></h1><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-hidden="true">#</a></h2><p><code>JS</code>是单线程的。<code>渲染线程</code> 和 <code>加载脚本</code>是互斥的，这也就是为什么长时间的脚本运行可能会导致页面失去响应的原因。 <br></p><p><img src="'+l+'" alt=""></p><blockquote><p><em><strong>在小程序中使用的是<code>Hybrid</code>的渲染方式，视图层和逻辑层是分开的，双线程同时运行，视图层使用<code>WebView</code>进行渲染，逻辑层运行在<code>JsCore</code>中</strong></em></p></blockquote><ul><li>渲染层: 界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以<code>渲染层存在多个 WebView 线程</code></li><li>逻辑层: 采用 JsCore 线程运行 JS 脚本，在这个环境下执行的都是有关小程序业务逻辑的代码</li></ul><h2 id="通信" tabindex="-1">通信 <a class="header-anchor" href="#通信" aria-hidden="true">#</a></h2><h3 id="渲染dom" tabindex="-1">渲染DOM <a class="header-anchor" href="#渲染dom" aria-hidden="true">#</a></h3><p>小程序在渲染层，宿主环境会把<code>wxml</code>转化成对应的<code>JS</code>对象,在<code>逻辑层发生数据变更时</code>，通过宿主环境提供的<code>setData</code>方法<code>把数据从逻辑层传递到渲染层</code>，再经过对比前后差异，把差异应用在原来的DOM树上，渲染出正确的视图。 <img src="'+t+'" alt=""></p><p>对于<code>事件的分发处理</code>，微信进行了特殊的处理，<code>将所有的事件拦截后</code>，丢到逻辑层交给JavaScript进行处理, 即页面更新是异步的，比如在<code>渲染首屏</code>的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来 如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作， 因此逻辑层与渲染层<code>需要有一定的机制保证时序正确</code>，在每个小程序页面的生命周期中，存在着若干次页面数据通信 <img src="'+i+'" alt=""></p><h2 id="运行机制" tabindex="-1">运行机制 <a class="header-anchor" href="#运行机制" aria-hidden="true">#</a></h2><p>小程序启动运行有两种情况:</p><ul><li>冷启动: 用户首次打开或者小程序被微信主动销毁后再次打开，此时需要重新加载启动</li><li>热启动: 用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台</li></ul><blockquote><p>注意：</p></blockquote><blockquote><p>1.小程序没有重启的概念<br> 2.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁<br> 3.短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了<br><img src="'+r+'" alt=""> 开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户 <br></p></blockquote><p><code>每次冷启动时，都会检查是否有更新版本</code>，如果发现有新版本，将会<code>异步下载新版本的代码包</code>，并同时用客户端本地的包进行启动，即<code>新版本的小程序需要等下一次冷启动才会应用上</code></p><h2 id="小程序与h5" tabindex="-1">小程序与H5 <a class="header-anchor" href="#小程序与h5" aria-hidden="true">#</a></h2><p>区别如下:</p><ul><li><strong><code>运行环境</code></strong>: 小程序基于浏览器内核重构的内置解析器</li><li><strong><code>系统权限</code></strong>: 小程序能获得更多的系统权限，如网络通信状态、数据缓存能力等</li><li><strong><code>渲染机制</code></strong>: 小程序的逻辑层和渲染层是分开的</li></ul><h2 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-hidden="true">#</a></h2><p>优点：</p><ul><li><strong><code>随搜随用，用完即走</code></strong></li><li><strong><code>流量大，易接受，小程序借助自身平台更容易引入更多流量</code></strong></li><li><strong><code>安全</code></strong></li><li><strong><code>开发门槛低</code></strong></li><li><strong><code>降低浏览器限制</code></strong></li></ul><p>缺点:</p><ul><li><strong><code>用户留存</code></strong>: 据有关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%</li><li><strong><code>包体积限制</code></strong>：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序</li><li><strong><code>受控微信</code></strong>：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控</li></ul>',24),s=[n];function h(p,g,u,_,b,m){return c(),o("div",null,s)}const x=e(a,[["render",h]]);export{f as __pageData,x as default};
