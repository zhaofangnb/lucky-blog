import{_ as e,c as o,o as t,d as c}from"./app.008430f5.js";const T=JSON.parse('{"title":"浏览器(Browser)","description":"","frontmatter":{},"headers":[{"level":2,"title":"preload 和 prefetch","slug":"preload-和-prefetch","link":"#preload-和-prefetch","children":[]},{"level":2,"title":"移动端触摸事件","slug":"移动端触摸事件","link":"#移动端触摸事件","children":[]},{"level":2,"title":"基于HTTP的前端鉴权","slug":"基于http的前端鉴权","link":"#基于http的前端鉴权","children":[{"level":3,"title":"http无状态","slug":"http无状态","link":"#http无状态","children":[]},{"level":3,"title":"cookie","slug":"cookie","link":"#cookie","children":[]}]}],"relativePath":"basic/html5/browser.md","lastUpdated":null}'),i={name:"basic/html5/browser.md"},l=c('<h1 id="浏览器-browser" tabindex="-1">浏览器(Browser) <a class="header-anchor" href="#浏览器-browser" aria-hidden="true">#</a></h1><h2 id="preload-和-prefetch" tabindex="-1">preload 和 prefetch <a class="header-anchor" href="#preload-和-prefetch" aria-hidden="true">#</a></h2><ul><li><code>preload</code>是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源</li><li><code>prefetch</code>是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源</li></ul><h2 id="移动端触摸事件" tabindex="-1">移动端触摸事件 <a class="header-anchor" href="#移动端触摸事件" aria-hidden="true">#</a></h2><ul><li><code>touchstart</code>事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，preventDefault()事件可以阻止滚动。</li><li><code>touchend</code>事件: 当手指从屏幕上离开的时候触发。</li></ul><ul><li><code>touchcancel</code>事件：当系统停止跟踪触摸的时候触发。</li></ul><p>每个Touch对象包含的属性如下: clientX: 触摸目标在视口中的x坐标。 clientY：触摸目标在视口中的y坐标。 identifier: 标识触摸的唯一ID。 pageX: 触摸目标在页面中的x坐标。 pageY: 触摸目标在页面中的y坐标。 screenX: 触摸目标在屏幕中的x坐标。 screenY: 触摸目标在屏幕中的y坐标。 target: 触摸的DOM节点目标。</p><h2 id="基于http的前端鉴权" tabindex="-1">基于HTTP的前端鉴权 <a class="header-anchor" href="#基于http的前端鉴权" aria-hidden="true">#</a></h2><h3 id="http无状态" tabindex="-1">http无状态 <a class="header-anchor" href="#http无状态" aria-hidden="true">#</a></h3><p>HTTP 请求方和响应方间无法维护状态，都是一次性的，它不知道前后的请求都发生了什么。</p><blockquote><p>最典型的，一个用户登陆微博，发布、关注、评论，都应是在登录后的用户状态下的。</p></blockquote><h3 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-hidden="true">#</a></h3><p>Cookie的一般过程是:</p><ul><li>在提供标记的接口，通过 HTTP 返回头的 <code>Set-Cookie</code> 字段，直接「种」到浏览器上</li><li>浏览器发起请求时，会自动把 cookie 通过<code> HTTP 请求头的 Cookie 字段</code>，带给接口</li></ul><p><code>「配置：Domain / Path」</code></p><p>cookie 是要限制::「空间范围」::的，通过 Domain（域）/ Path（路径）两级。</p><blockquote><p>Domain属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前 URL 的一级域名，比如<code>www.example.com</code>会设为<code>example.com</code>，而且以后如果访问example.com的任何子域名，HTTP 请求也会带上这个 Cookie。如果服务器在Set-Cookie字段指定的域名，不属于当前域名，浏览器会拒绝这个 Cookie。</p></blockquote><blockquote><p>Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，PATH属性是/，那么请求/docs路径也会包含该 Cookie。当然，前提是域名必须一致。</p></blockquote><p><code>「配置：Expires / Max-Age」</code></p><blockquote><p>Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 <code>UTC</code> 格式。如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。</p></blockquote><blockquote><p>Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。</p></blockquote><blockquote><p>如果同时指定了Expires和Max-Age，那么<code>Max-Age</code>的值将优先生效。</p></blockquote><blockquote><p>如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个 Cookie 就是 <code>Session Cookie</code>，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p></blockquote><p><code>「配置：Secure / HttpOnly」</code></p><blockquote><p>Secure属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的Secure属性。该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。</p></blockquote><blockquote><p>HttpOnly属性指定该 <code>Cookie 无法通过 JavaScript 脚本拿到</code>，主要是<code>Document.cookie</code>属性、<code>XMLHttpRequest对象</code>和 <code>Request API </code>都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p></blockquote>',26),a=[l];function d(r,p,h,n,s,k){return t(),o("div",null,a)}const b=e(i,[["render",d]]);export{T as __pageData,b as default};
