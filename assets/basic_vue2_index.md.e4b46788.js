import{_ as e,c as t,o as d,d as a}from"./app.008430f5.js";const _=JSON.parse('{"title":"Vue2","description":"","frontmatter":{},"headers":[{"level":3,"title":"computed 和 methods 的区别","slug":"computed-和-methods-的区别","link":"#computed-和-methods-的区别","children":[]},{"level":3,"title":"key的作用","slug":"key的作用","link":"#key的作用","children":[]},{"level":3,"title":"diff算法核心原理","slug":"diff算法核心原理","link":"#diff算法核心原理","children":[]},{"level":3,"title":"父子组件生命周期先后顺序","slug":"父子组件生命周期先后顺序","link":"#父子组件生命周期先后顺序","children":[]}],"relativePath":"basic/vue2/index.md","lastUpdated":null}'),i={name:"basic/vue2/index.md"},l=a('<h1 id="vue2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2" aria-hidden="true">#</a></h1><h3 id="computed-和-methods-的区别" tabindex="-1">computed 和 methods 的区别 <a class="header-anchor" href="#computed-和-methods-的区别" aria-hidden="true">#</a></h3><ul><li>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。</li><li>然而，不同的是计算属性是基于它们的响应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。</li><li>这就意味着只要依赖项还没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。</li></ul><h3 id="key的作用" tabindex="-1">key的作用 <a class="header-anchor" href="#key的作用" aria-hidden="true">#</a></h3><p>比如一个列表，需要往中间插入一个元素，如果<code>以下标作为对应关系</code>时，<code>不使用key</code>或者<code>使用列表的index作为key</code>,会导致插入元素到后面的全部元素，对应的位置关系发生变更，全都需要执行更新操作。</p><p>我们希望的是只渲染添加的那一个元素， 其他元素不做任何变更。</p><p><code>使用唯一key值</code>: 只会渲染要更新的元素，其他元素内容没发生改变，对应的位置关系也没有发生改变。</p><p>总结特点:</p><ul><li>key 的作用主要是为了更高效的更新虚拟 DOM，因为它可以非常精确的找到相同节点，因此 patch 过程会非常高效</li><li>Vue 在 patch 过程中会判断两个节点是不是相同节点时，key 是一个必要条件。比如渲染列表时，如果不写 key，Vue 在比较的时候，就可能会导致频繁更新元素，使整个 patch 过程比较低效，影响性能</li><li>应该避免使用数组下标作为 key</li></ul><h3 id="diff算法核心原理" tabindex="-1">diff算法核心原理 <a class="header-anchor" href="#diff算法核心原理" aria-hidden="true">#</a></h3><h4 id="patch" tabindex="-1">patch <a class="header-anchor" href="#patch" aria-hidden="true">#</a></h4><p>它可以接收四个参数:</p><ul><li>oldValue : 老的虚拟DOM节点</li><li>vnode ：新的虚拟DOM节点</li><li>hydrating: 是不是要和真实DOM混合</li><li>removeOnly</li></ul><h3 id="父子组件生命周期先后顺序" tabindex="-1">父子组件生命周期先后顺序 <a class="header-anchor" href="#父子组件生命周期先后顺序" aria-hidden="true">#</a></h3><blockquote><p>挂载阶段</p></blockquote><p>执行顺序为： 父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted</p><blockquote><p>更新阶段</p></blockquote><ul><li>执行顺序为： 父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</li></ul><blockquote><p>销毁阶段</p></blockquote><ul><li>执行顺序为： 父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed；</li></ul><p>规律就是：父组件先开始执行，然后等到子组件执行完，父组件收尾。</p>',21),o=[l];function r(c,h,n,u,s,p){return d(),t("div",null,o)}const k=e(i,[["render",r]]);export{_ as __pageData,k as default};
